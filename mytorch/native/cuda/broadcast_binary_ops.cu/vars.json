[
    {
        "name": "add",
        "arg_type": "T alpha,",
        "op": "output[xid] = x[pair.x] + y[pair.y] * alpha",
        "op_backward": "do { atomicAdd(&x_grad[pair.x], output_grad[xid]); atomicAdd(&y_grad[pair.y], output_grad[xid] * alpha); } while (0)"
    },
    {
        "name": "sub",
        "arg_type": "T alpha,",
        "op": "output[xid] = x[pair.x] - y[pair.y] * alpha",
        "op_backward": "do { atomicAdd(&x_grad[pair.x], output_grad[xid]); atomicAdd(&y_grad[pair.y], -output_grad[xid] * alpha); } while (0)"
    },
    {
        "name": "mul",
        "arg_type": "",
        "op": "output[xid] = x[pair.x] * y[pair.y]",
        "op_backward": "do { atomicAdd(&x_grad[pair.x], output_grad[xid] * y[pair.y]); atomicAdd(&y_grad[pair.y], output_grad[xid] * x[pair.x]); } while (0)"
    },
    {
        "name": "div",
        "arg_type": "",
        "op": "output[xid] = x[pair.x] / y[pair.y]",
        "op_backward": "do { atomicAdd(&x_grad[pair.x], output_grad[xid] / y[pair.y]); atomicAdd(&y_grad[pair.y], output_grad[xid] * (-x[pair.x] / (T)pow(y[pair.y], 2))); } while (0)"
    },
    {
        "name": "pow",
        "arg_type": "",
        "op": "output[xid] = (T)pow((float)x[pair.x], (float)y[pair.y])",
        "op_backward": "do { atomicAdd(&x_grad[pair.x], output_grad[xid] * y[pair.y] *(T)pow((float)x[pair.x], (float)y[pair.y] - 1)); atomicAdd(&y_grad[pair.y],output_grad[xid] * (T)pow((float)x[pair.x], (float)y[pair.y]) * (T)logf((float)x[pair.x])); } while (0)"
    },
    {
        "name": "copy",
        "arg_type": "",
        "op": "x[pair.x] = y[pair.y]"
    }
]