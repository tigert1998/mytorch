#include <cuda_fp16.h>

#include <cuda/std/limits>

#include "reduce_utils.cuh"

template <typename T>                                                       
__global__ void {name}_reference(int n, T* input, {arg_type} int shape_n,  
                                 int* shape, int num_reduce_axis,           
                                 int* reduce_axis, T* output) {{             
  int lane_id = threadIdx.x % warpSize;                                     
  int warp_id = threadIdx.x / warpSize;                                     
  const int num_warps = blockDim.x / warpSize;                              
  extern __shared__ char shared[];                                          
  T* buffer = (T*)shared;                                                   
  int inner = 1;                                                            
  for (int i = 0; i < num_reduce_axis; i++) inner *= shape[reduce_axis[i]]; 
  int outer = n / inner;                                                    
  for (int x = blockIdx.y; x < outer; x += gridDim.y) {{                     
    T value = {init};                                                       
    for (int i = warp_id * warpSize + lane_id; i < inner;                   
         i += num_warps * warpSize) {{                                       
      int idx = restore_reduction(shape_n, shape, num_reduce_axis,          
                                  reduce_axis, x, i);                       
      T other_value = input[idx];
      {op};                                                
    }}                                                                       
    for (int offset = warpSize / 2; offset > 0; offset >>= 1) {{             
      T other_value = __shfl_xor_sync(0xFFFFFFFF, value, offset);           
      {op};                                               
    }}                                                                       
    if (lane_id == 0) {{                                                     
      buffer[warp_id] = value;                                              
    }}                                                                       
    __syncthreads();                                                        
    if (warp_id == 0) {{                                                     
      T value = lane_id * num_warps < inner ? buffer[lane_id] : {init};     
      for (int offset = warpSize / 2; offset > 0; offset >>= 1) {{           
        T other_value = __shfl_xor_sync(0xFFFFFFFF, value, offset);         
        {op};                                             
      }}                                                                     
      if (lane_id == 0) {{                                                   
        output[x] = {finalize};                                           
      }}                                                                     
    }}                                                                       
  }}          
}}                                                               
